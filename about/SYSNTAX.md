# Синтаксис

## Коментарии

```
Ё любой код окруженный в большую ё считается коментарием Ё

а = Ё
коментарии в ё могут быть в любом месте и не мешать коду
Ё 10;


Ё
если ё не закрыта, то концом коментария будет считаться конец файла
```

## Разделители

Любые выражения (Statements) могут быть разделены а могут и нет разделителями. 
Если разделителя нету может наблюдаться непредвиденное поведение у некоторых выражений.<br>
Разделителем считается , или ;

```
а = 10; б = 5,
;;;;;;;;;;;,;,;,,;,;,;,,,;,;,;
```

В большинстве выражений где используется перечисление чего либо, например, как аргументы в функции
разделителем так же может быть не лишь обычная запятая но и точка с запятой.<br>
После блока \{\} разделитель не нужен как и в конце файла. Если был использован разделитель но без 
какого либо выражения, то это будет считаться пустым выражением.

## Вывод в консоль

Всё что просто стоит без какого-лиюо выражения пишется в консоль, если оно допустимо.
Кроме этого есть также слово "начертать", что делает самое же.

```

"123";
123;
истина;
начертать [1, 2];

```

Для вывода нескольких значений в одну строку имеется функция "очерк".

```

очерк(123, 123, 32, "фыв", истина, [13, 13]);

```

## Объявление переменных

```

а = 10;
а = "йцук";
а = истина; а = аминь;
а = ложь;
а = [123, "йцук"; истина, сумма => (а, б): вернуть а + б;, новый Дуб(высота = 100); [[[321]], б]];

```

## Ввод в консоль

Для ввода в консоль используются слова:
- хартия
- ввод
- ввести
- харатья

! Они являются функциями а потому изменяемы !

Возвращает строку.

```

а = хартия("ведите а: ").числом();
а;

```

## Математические выражения

- "+" плюс
- "-" минус
- "*" умножить
- "/" делить
- "**" степень
- "%" остаток
- "//" деление без остатка
- "синус" синус
- "косинус" косинус
- "потолок" округление к большему
- "пол" к меньшему
- "тангенс" тангенс
- "макс", "большее", "максимум", "наибольшее" дословно, принимает несколько значений или лист
- "мин", "меньшее", "минимум", "наименьшее" дословно, принимает несколько значений или лист
- "корень" корень
- "ПИ" число пи
- "Е" число е

## Логические выражения

Слова, которые можно использовать в смысле слова "если":

- "егда"
- "еже"
- "если"
- "коль"
- "ежели"

Слово "иначе" таковым и является.

В качестве оператора "не" можно использовать как и само "не" так же и символ "!".

Также прочие вариации для различных слов в логических выражениях:

истина:
- "истина"
- "правда"
- "реснота"
- "аминь"

ложь:
- "ложь"

и:
- "и"
- "&&"

или:
- "или"
- "||"

больше:
- "больше"
- "паче"
- "вяще"
- ">"

меньше:
- "меньше"
- "<"

прочие:
- ">="
- "<="

После самого логического выражения в большинство языков если ничего не стоит, то выполняется
одно действие, а \{де; йс; тв; я;\} представляет из себя тоже действие.
В данном же языке если, используется ":", то будет выполненно лишь одно действие, а если внутри \{\},
то сколько угодно. Исключением является лишь объявление тела классов, где вместо \{\} могут 
использоваться и обычные скобки.

В будущем блок из : или \{\} будет писаться как БЛОК, а следовательно вид данного выражния:

```

если <выражнение>
	БЛОК
иначе 
	БЛОК

```

```

а = 10;
если а % 2 == 0 {
	а;
	10;
	9;
	8;
}
иначе:
	-1;

```

## Циклы

Есть два базовых цикла цикл "пока"(while) и "для"()for, а также цикл "цикл", который остановится
только через "выход". Имеется слово "продолжить" для того что бы начать иттераию цикла преждевременно.

```

пока <выражение>
	БЛОК

для <назначение> <разделитель> <выражение> <разделитель> <назначение> 
	БЛОК

цикл
	БЛОК

```

```

пока а паче -10:
	--а;
а;

для а = 10; а больше -100; --а:
	а;

цикл {
	++а;
	если а паче 50:
		выйти;
}
а;

```

## Функции

Функции могут объявляться через "=>" или "===" с последующими аргументами в скобках и блоком далее.

Для возвращения значения используются слова:
- "воздать"
- "вернуть"
- "яти"
- "чтить"
- "пояти"
- "славить"

```

название <"=>" или "==="> (ар, гу, ме, нты) 
	БЛОК

```

```

сумма => (а, б):
	вернуть а + б;

дискрименант === (а, б; с) {
	д = корень(б*б - 4 а с);
	воздать [(-б + д) / (2а), (-б - д) / (2а)];
}

дискрименант(2, 2**4, 1);
дискрименант(2, 16, 1);

```

Процедур, как отдельного типа данных нету, а потому любая функция, которая даже ничего не возвращает
будет пясать в консоль после себя 0. Что бы этог7о избежать и просто выполнить функци. используются слова:
- "деяти"
- "выполнить"
- "процедура"
- "процедуру"

```

написать_строку === (символ, н):
	символ н;

деяти написать_строку("*", 10);
выполнить написать_строку("@", 11);
процедура написать_строку("#", 12);
процедуру написать_строку("%", 13);

```

### Лямбда-функции

Также имеются лямбда-функции в объявлении кторых может использоваться и как слово "лямбда" так и "==="
или "функция".

```

в ЯЧисло.квадрат = функция я: я я;
2 .квадрат();

в ЯЧисло.куб = лямбда я: { а = я; б = я; с = я; воздать а б с; };
2 .куб();

в ЯЧисло.эээ = === я: { а = я; б = я; с = я; воздать а б с а б с; };
2 .эээ();


```

## Классы

```

класс Йц ()
класс Йц {}
Ё для удобства вместо { можно использовать обычные ( Ё

```

Классы не имеют конструкторы зато все вместе с именами можно обозначить сразу при создании объекта.
Если есть неоходимость то в классе можно указать значенися по умолчанию а при объявлении их менять.

```

класс Прямоугольник (
	высота = 2222;
	ширина = 22;

	площадь === ():
		воздать высота ширина;
)

прям = новый Прямоугольник(высота = 10);
прям.площадь();
Ё вернёт 220 так как высота стала 10 Ё

```

### Атрибуты

Получать атрибуты можно обычным способом но для их назначения следует использовать слово "в".

```

класс Йц ()

а = новый Йц(б = новый Йц(с = новый Йц(г = 10, длина === (): воздать -100;)));
а.б.с.г;

в а.б.ы = 123;
Ё свово "в" обозначается для того куда будет добавленно значение Ё

в а.х === (высота, ширина): воздать высота высота высота ширина;
а.х(12, 34);
а.х;

```

Методы назначаются так же, как и атрибуты, и не имеют никакого различия

## Разные слова

"сейчас" дает сейчас

"чистка" очищает консоль

"сон" делает задержку в мс

"русить" позволяет выполнить код данного языка подобно exec python


# Особенности

## Использование переменных

Любая не объявленная переменная будет равна 0, а не ошибкой

## Методы

Внутри методов классов запрещенно использовать переменные с названием самого объекта.

В данном примере также описывается использование магического метода "строкой", который 
позволяет при выводе объекта в консоль получить не <ОБЪЕКТ КЛАССА чтототам>, а желаемое значение, 
а также и в случае попытки приведения объекта данного класса к строке подобно функции "строкой(значение)".

```
класс Прямоугольник {
	высота = 22;
	ширина = 2222;

	площадь === ():
		воздать высота * ширина;

	строкой === () {
		а = "нельзя так";
		воздать а;
	}
}

а = новый Прямоугольник();

а.ширина;
Ё вернет 2222 и ничего не произойдёт но Ё

а;
Ё заменит обьект а на строку "нельзя так" и уже далее а.ширина будет ошибкой Ё

```

## Магические методы

Имеется возможность настраивть для объектов магические методы бинарных операций(+, -, * и т.д.).
Список настраевыемых методов и их названия
- _плюс
- _минус
- _умножить
- _делить
- _степень
- _остаток
- _безостаточный

```

класс Прямоугольник{
	_делить === (другой):
		воздать новый Прямоугольник(высота = другой.высота / высота, ширина = другой.ширина / ширина);
}

прям = новый Прямоугольник(высота = 10, ширина = 4.);
прям2 = новый Прямоугольник(высота = 10000, ширина = 10000);

а = (прям2 / прям).ширина;
а.ширина;
Ё выдаст 0,0004 а в объекте "а" будет высота 0 и ширина 0,0004 Ё

```

## Функции

Все функции являются обьектами, а следовательно могут иметь и свои аттрибуты и даже функции.
Технически функция является просто обычным объектом, который можно вызвать с помощью "()".

```

класс Прямоугольник(
	высота = 1;
	ширина = 1;

	площадь === ():
		воздать высота ширина;
)

прям = новый Прямоугольник(высота = 10);

прям.площадь();
в прям.площадь.чтото === (): воздать прям.высота прям.высота;
прям.площадь.чтото();

```

## Специальные объекты - типы

Есть ряд обЪектов которые представляют собой типы данных:

- ЯЧисло - все целые числа
- ЯТочка - все не целые числа
- ЯСтрока - все строки
- ЯПравда - вся Истина и Ложь
- ЯЛист - все листы

Исходя из названия они употребляются как классы для определения методов и атрибутов
 для их типов переменных.

 ```

Ё пример Ё

класс Прямоугольник()

прям = новый Прямоугольник(высота = 10);

123 .строкой();
прям.высота.строкой();

в ЯЧисло.квадрат === (я): воздать я я;
2 .квадрат();

в ЯЧисло.умножить === (я, айте): воздать я айте;
2 .умножить(24);

в ЯЧисло.пи = ПИ;
123 .пи;
 
 ```

 В попытке использовать их как объект будут возникать ошибки с текстом вероятнее всего типа:

 ```
 
 ЯЧисло;
 Ё результат: НЕДОСТАТОЧНО АРГУМЕНТОВ ДЛЯ <СТРОЧИТЬ(<>)>, БЫЛО: <0> Ё

 ЯЧисло(1);
 Ё результат: НЕ ЯВЛЯЕТСЯ ОБЬЕКТОМ ДЛЯ ВЫЗОВА: <ЯЧисло> Ё

 ```

Так же наследование от них или попытка из них создать новый объект
приведёт к аналогичному результату. При этом сами они могут быть переопределены и
даже вполне утерянны для доступа по имени но их атрибуты и методы останутся какими и были
в конце.