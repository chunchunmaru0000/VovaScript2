# Синтаксис

## Коментарии

```
Ё любой код окруженный в большую ё считается коментарием Ё

а = Ё
коментарии в ё могут быть в любом месте и не мешать коду
Ё 10;


Ё
если ё не закрыта, то концом коментария будет считаться конец файла
```

## Разделители

Любые выражения (Statements) могут быть разделены а могут и нет разделителями. 
Если разделителя нету может наблюдаться непредвиденное поведение у некоторых выражений.<br>
Разделителем считается , или ;

```
а = 10; б = 5,
;;;;;;;;;;;,;,;,,;,;,;,,,;,;,;
```

В большинстве выражений где используется перечисление чего либо, например, как аргументы в функции
разделителем так же может быть не лишь обычная запятая но и точка с запятой.<br>
После блока \{\} разделитель не нужен как и в конце файла. Если был использован разделитель но без 
какого либо выражения, то это будет считаться пустым выражением.

## Вывод в консоль

Всё что просто стоит без какого-лиюо выражения пишется в консоль, если оно допустимо.
Кроме этого есть также слово "начертать", что делает самое же.

```

"123";
123;
истина;
начертать [1, 2];

```

Для вывода нескольких значений в одну строку имеется функция "очерк".

```

очерк(123, 123, 32, "фыв", истина, [13, 13]);

```

## Объявление переменных

```

а = 10;
а = "йцук";
а = истина; а = аминь;
а = ложь;
а = [123, "йцук"; истина, сумма => (а, б): вернуть а + б;, новый Дуб(высота = 100); [[[321]], б]];

```

## Ввод в консоль

Для ввода в консоль используются слова:
- хартия
- ввод
- ввести
- харатья

! Они являются функциями а потому изменяемы !

Возвращает строку.

```

а = хартия("ведите а: ").числом();
а;

```

## Математические выражения

- "+" плюс
- "-" минус
- "*" умножить
- "/" делить
- "**" степень
- "%" остаток
- "//" деление без остатка
- "синус" синус
- "косинус" косинус
- "потолок" округление к большему
- "пол" к меньшему
- "тангенс" тангенс
- "макс", "большее", "максимум", "наибольшее" дословно, принимает несколько значений или лист
- "мин", "меньшее", "минимум", "наименьшее" дословно, принимает несколько значений или лист
- "корень" корень
- "ПИ" число пи
- "Е" число е

## Индексы массивов и строк

В данном случае ниже 1 это от куда, -2 до куда и 3 один элемент листа. -2 значит второй с конца.
```
"1234567890"[1:-2][3];
```

В данном случае ниже это значит от 4 индекса и до конца.
```
"1234567890"[4:];
```

В данном случае ниже это значит от начала индекса и до -4 индекса.
```
"1234567890"[:-4];
```

В данном случае ниже это значит все значения.
```
"1234567890"[:];
```

В отличие от питона где что бы выбрать с отрицательным шагом нужно писать 
- a[-1:1:-2]

И это выглядит не понятно, в данном языке все имеет смысл и переставлять
значения не имеет смиысл, получая логичное и понятное a[1:-1:-2].

Примеры

```

"1234567890"[1:-2][1:-2];
"1234567890"[1:-2][1:-2][3];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][1:-2][1:-2];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][1:-2][1:-2][3].строкой();
"---------------------------------------------------------------------";
"1234567890".строкой()[1:-2][1:-2][3];
"1234567890"[1:-2].строкой()[1:-2][3];
"1234567890"[1:-2].строкой()[1:-2][3].строкой();
"1234567890".строкой()[1:-2].строкой()[1:-2].строкой()[3].строкой()[0];
"---------------------------------------------------------------------";
"1234567890"[4:];
"1234567890"[:-2];
"1234567890"[:];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][4:];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][:-2];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][:];
"---------------------------------------------------------------------";
"1234567890"[::1];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][::1];
"1234567890"[::5];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][::2];
"1234567890"[::-5];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0][::-2];

```

Для назначения атрибутов классов используется слово "в", а для назначения значения листа
исползуется слово "где", а так же так как имеется возможность назначать сколько угодно
элементов используя слово "заполни" или "заполнить" по количеству изначального листа то, 
если имеется надобность сделать проверку на точное количество используется слово "точно" перед
знаком равно, и если количества назначаемых и значений разное, то выйдет ошибка. Если слово
"заполни" использованно не было но использовалить шаги, то всё заполнится. Из указанного выше
следует, что использовать слово "точно" со словом "заполни" не повлечет за собой какого либо эффекта.

```

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[:-1] = [10];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[1:-1][1:-1:-2] = 222;
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[1:-1][2:-2] = [10, 10, 10, 10, 10, 10];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[1:-1][2:-2] точно = [10, 10, 10, 10];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[1:-1][2:-2] = a[:4];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[:] = a[:4];
a;

a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
где a[1:-1][1:-1:-2] точно = [10, 10, 10, 10, 10, 10];
Ё в последнем возникнет ошибка Ё

Ё и примеры с объектами Ё
класс Йц()
б = новый Йц(лист = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0], строка = "1234567890");

б.лист;
б.строка;

б.лист[1:-2][1:-2];
б.строка[1:-2][1:-2];

б.лист[1:-1][1:-1:-2];
б.строка[1:-1][1:-1:-2];


где б.лист[1:-1][1:-1:-2] заполни = [10, 10, 10, 10, 10, 10];
где б.строка[1:-1][1:-1:-2] заполни = [10, 10, 10, 10, 10, 10];

б.лист;
б.строка;

```

## Логические выражения

Слова, которые можно использовать в смысле слова "если":

- "егда"
- "еже"
- "если"
- "коль"
- "ежели"

Слово "иначе" таковым и является.

В качестве оператора "не" можно использовать как и само "не" так же и символ "!".

Также прочие вариации для различных слов в логических выражениях:

истина:
- "истина"
- "правда"
- "реснота"
- "аминь"

ложь:
- "ложь"

и:
- "и"
- "&&"

или:
- "или"
- "||"

больше:
- "больше"
- "паче"
- "вяще"
- ">"

меньше:
- "меньше"
- "<"

прочие:
- ">="
- "<="

После самого логического выражения в большинство языков если ничего не стоит, то выполняется
одно действие, а \{де; йс; тв; я;\} представляет из себя тоже действие.
В данном же языке если, используется ":", то будет выполненно лишь одно действие, а если внутри \{\},
то сколько угодно. Исключением является лишь объявление тела классов, где вместо \{\} могут 
использоваться и обычные скобки.

В будущем блок из : или \{\} будет писаться как БЛОК, а следовательно вид данного выражния:

```

если <выражнение>
	БЛОК
иначе 
	БЛОК

```

```

а = 10;
если а % 2 == 0 {
	а;
	10;
	9;
	8;
}
иначе:
	-1;

```

Имеется сокращение в виде:

```

(логическое выражение ? возвращает если истина : или если ложь)

```

Должно быть обязательно в скобках

## Диапазон

```

а = от 10 до -10;
а;
Ё результат: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10] Ё

а = от -10 до 10;
а;
Ё результат: [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Ё

а = от 0 до 1;
а;
Ё результат: [0, 1] Ё

а = от 1 до 1;
а;
Ё результат: [1] Ё

от "1" до "9";
Ё результат: "123456789" Ё

от "а" до "я";
Ё результат: "абвгдежзийклмнопрстуфхцчшщъыьэюя" Ё

от "я" до "А";
Ё результат: "яюэьыъщшчцхфутсрпонмлкйизжедгвбаЯЮЭЬЫЪЩШЧЦХФУТСРПОНМЛКЙИЗЖЕДГВБА" Ё

от 10 до 100 шаг 5;
Ё результат: [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100] Ё

от 10 до 100 шаг -5;
Ё результат: [100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10] Ё

от 10 до -100 шаг -5;
Ё результат: [10, 5, 0, -5, -10, -15, -20, -25, -30, -35, -40, -45, -50, -55, -60, -65, -70, -75, -80, -85, -90, -95, -100] Ё

```

## Циклы

Есть два базовых цикла цикл "пока"(while) и "для"()for, а также цикл "цикл", который остановится
только через "выход". Имеется слово "продолжить" для того что бы начать иттераию цикла преждевременно.

```

пока <выражение>
	БЛОК

для <назначение> <разделитель> <выражение> <разделитель> <назначение> 
	БЛОК

цикл
	БЛОК

```

```

пока а паче -10:
	--а;
а;

для а = 10; а больше -100; --а:
	а;

цикл {
	++а;
	если а паче 50:
		выйти;
}
а;

```

Цикл ДляВ имеет более продвинутый синтаксис, где можно указать не только имя переменной которая
будет использованна при проходе по листу но и также указать на переменную, на которую она ссылается,
представляет и изменяет в процессе так, что можно обращаться и к самому иттератору и к переменной,
на которую он ссылается и получить одинаковый результат. В отличие от питона, где подоюной переменной
может быть кроме более обычных случаев лишь один элемент листа, то в данном языке иттератор
может ссылаться на целый срез и даже в строке.

Слова который/ая/ое используются для обозначения на какую переменную будет ссылаться иттератор.

```

класс Йц()
б = новый Йц(лист = от 0 до 9, строка = от "а" до "я");

где б.лист[1:-1][1:-1:-2] заполнить = [10, 10, 10, 10, 10, 10];
где б.строка[1:-1][1:-1:-2] заполнить = 9;

б.лист;
б.строка;;
"#######################";
Ё успех
для сч который б.лист в от "а" до "о":
	б.лист;
Ё
Ё успех
а = [1, 3, 4, 5];
для сч который а[1] в от "а" до "о":
	а;
Ё
Ё успех
для сч в от "а" до "о":
	сч;
Ё
Ё успех
для сч который б.лист[:2] в от "а" до "о":
	б.лист;
Ё

```

## Функции

Функции могут объявляться через "=>" или "===" с последующими аргументами в скобках и блоком далее.

Для возвращения значения используются слова:
- "воздать"
- "вернуть"
- "яти"
- "чтить"
- "пояти"
- "славить"

```

название <"=>" или "==="> (ар, гу, ме, нты) 
	БЛОК

```

```

сумма => (а, б):
	вернуть а + б;

дискрименант === (а, б; с) {
	д = корень(б*б - 4 а с);
	воздать [(-б + д) / (2а), (-б - д) / (2а)];
}

дискрименант(2, 2**4, 1);
дискрименант(2, 16, 1);

```

Процедур, как отдельного типа данных нету, а потому любая функция, которая даже ничего не возвращает
будет пясать в консоль после себя 0. Что бы этог7о избежать и просто выполнить функци. используются слова:
- "деяти"
- "выполнить"
- "процедура"
- "процедуру"

```

написать_строку === (символ, н):
	символ н;

деяти написать_строку("*", 10);
выполнить написать_строку("@", 11);
процедура написать_строку("#", 12);
процедуру написать_строку("%", 13);

```

### Лямбда-функции ! СЕЙЧАС РАБОТАЮТ ТОЛЬКО, ЕСЛИ ОБЪЯВИТЬ ВНУТРИ русить В КАЧЕСТВЕ КОДА

Также имеются лямбда-функции в объявлении кторых может использоваться и как слово "лямбда" так и "==="
или "функция".

```

в ЯЧисло.квадрат = функция я: я я;
2 .квадрат();

в ЯЧисло.куб = лямбда я: { а = я; б = я; с = я; воздать а б с; };
2 .куб();

в ЯЧисло.эээ = === я: { а = я; б = я; с = я; воздать а б с а б с; };
2 .эээ();


```

## Классы

```

класс Йц ()
класс Йц {}
Ё для удобства вместо { можно использовать обычные ( Ё

```

Классы не имеют конструкторы зато все вместе с именами можно обозначить сразу при создании объекта.
Если есть неоходимость то в классе можно указать значенися по умолчанию а при объявлении их менять.

```

класс Прямоугольник (
	высота = 2222;
	ширина = 22;

	площадь === ():
		воздать высота ширина;
)

прям = новый Прямоугольник(высота = 10);
прям.площадь();
Ё вернёт 220 так как высота стала 10 Ё

```

### Атрибуты

Получать атрибуты можно обычным способом но для их назначения следует использовать слово "в".

```

класс Йц ()

а = новый Йц(б = новый Йц(с = новый Йц(г = 10, длина === (): воздать -100;)));
а.б.с.г;

в а.б.ы = 123;
Ё свово "в" обозначается для того куда будет добавленно значение Ё

в а.х === (высота, ширина): воздать высота высота высота ширина;
а.х(12, 34);
а.х;

```

Методы назначаются так же, как и атрибуты, и не имеют никакого различия

## Разные слова

"сейчас" дает сейчас

"чистка" очищает консоль

"сон" делает задержку в мс

"русить" позволяет выполнить код данного языка подобно exec python


# Особенности

## Использование переменных

Любая не объявленная переменная будет равна 0, а не ошибкой

## Методы

Внутри методов классов запрещенно использовать переменные с названием самого объекта.

В данном примере также описывается использование магического метода "строкой", который 
позволяет при выводе объекта в консоль получить не <ОБЪЕКТ КЛАССА чтототам>, а желаемое значение, 
а также и в случае попытки приведения объекта данного класса к строке подобно функции "строкой(значение)".

```
класс Прямоугольник {
	высота = 22;
	ширина = 2222;

	площадь === ():
		воздать высота * ширина;

	строкой === () {
		а = "нельзя так";
		воздать а;
	}
}

а = новый Прямоугольник();

а.ширина;
Ё вернет 2222 и ничего не произойдёт но Ё

а;
Ё заменит обьект а на строку "нельзя так" и уже далее а.ширина будет ошибкой Ё

```

## Магические методы

Имеется возможность настраивть для объектов магические методы бинарных операций(+, -, * и т.д.).
Список настраевыемых методов и их названия
- _плюс
- _минус
- _умножить
- _делить
- _степень
- _остаток
- _безостаточный

```

класс Прямоугольник{
	_делить === (другой):
		воздать новый Прямоугольник(высота = другой.высота / высота, ширина = другой.ширина / ширина);
}

прям = новый Прямоугольник(высота = 10, ширина = 4.);
прям2 = новый Прямоугольник(высота = 10000, ширина = 10000);

а = (прям2 / прям).ширина;
а.ширина;
Ё выдаст 0,0004 а в объекте "а" будет высота 0 и ширина 0,0004 Ё

```

## Функции

Все функции являются обьектами, а следовательно могут иметь и свои аттрибуты и даже функции.
Технически функция является просто обычным объектом, который можно вызвать с помощью "()".

```

класс Прямоугольник(
	высота = 1;
	ширина = 1;

	площадь === ():
		воздать высота ширина;
)

прям = новый Прямоугольник(высота = 10);

прям.площадь();
в прям.площадь.чтото === (): воздать прям.высота прям.высота;
прям.площадь.чтото();

```

## Специальные объекты - типы

Есть ряд обЪектов которые представляют собой типы данных:

- ЯЧисло - все целые числа
- ЯТочка - все не целые числа
- ЯСтрока - все строки
- ЯПравда - вся Истина и Ложь
- ЯЛист - все листы

Исходя из названия они употребляются как классы для определения методов и атрибутов
 для их типов переменных.

 ```

Ё пример Ё

класс Прямоугольник()

прям = новый Прямоугольник(высота = 10);

123 .строкой();
прям.высота.строкой();

в ЯЧисло.квадрат === (я): воздать я я;
2 .квадрат();

в ЯЧисло.умножить === (я, айте): воздать я айте;
2 .умножить(24);

в ЯЧисло.пи = ПИ;
123 .пи;
 
 ```

 В попытке использовать их как объект будут возникать ошибки с текстом вероятнее всего типа:

 ```
 
 ЯЧисло;
 Ё результат: НЕДОСТАТОЧНО АРГУМЕНТОВ ДЛЯ <СТРОЧИТЬ(<>)>, БЫЛО: <0> Ё

 ЯЧисло(1);
 Ё результат: НЕ ЯВЛЯЕТСЯ ОБЬЕКТОМ ДЛЯ ВЫЗОВА: <ЯЧисло> Ё

 ```

Так же наследование от них или попытка из них создать новый объект
приведёт к аналогичному результату. При этом сами они могут быть переопределены и
даже вполне утерянны для доступа по имени но их атрибуты и методы останутся какими и были
в конце.

### Пример рекурсии во встроенном типе

```

в ЯЧисло.ф === (ч): воздать (ч <= 1 ? 1 : ч ЯЧисло.ф(ч - 1));

12 .ф();

```